# Geographic analysis

In the previous chapter, we looked at the demographics of Census blocks in Baltimore city and made a nice map. Let's go little further and combine demographic data with political data to learn more about Maryland's political geography.

First, let's load the libraries we'll need. We're also going to load tidycensus and set an API key for tidycensus.

```{r}
#| output: false
library(tidyverse)
library(sf)
library(janitor)
library(tidycensus)
census_api_key("549950d36c22ff16455fe196bbbd01d63cfbe6cf")

```

And now let's load a dataframe of Maryland county population information from the 2020 Census, but this time we'll add in county geographic data.

```{r}
#| error: true

maryland_counties <- read_csv("data/md_counties_2020.csv")
maryland_county_shapes <- st_read("data/Maryland2020_County.json")

maryland_counties_with_shapes <- maryland_counties %>% inner_join(maryland_county_shapes, by=c('GEOID'='GEOID20'))

```
And there's that join error: we've got incompatible data types. We can quickly fix that:

```{r}
maryland_counties <- read_csv("data/md_counties_2020.csv") %>% mutate(GEOID = as.character(GEOID))
maryland_county_shapes <- st_read("data/Maryland2020_County.json")

maryland_counties_with_shapes <- maryland_counties %>% inner_join(maryland_county_shapes, by=c('GEOID'='GEOID20'))
```
For the rest of this chapter, we're going to work on building a map that will help us gain insight into geographic patterns in registered voters and population by county and in Maryland. Our starting question: by examining the number of voters and the population in each county, what regional geographic patterns can we identify?

First we need to load voter registration data - since the population data is from 2020, we'll use the county totals as of the 2020 general election. And we'll make sure that the FIPS code that we need to join on is a character column:

```{r}
maryland_voters_by_county <- read_csv("data/maryland_voters_2020g.csv") %>% mutate(FIPS=as.character(FIPS))
```

Now let's combine our two dataframes:

```{r}
maryland_voters_by_county_with_pop <- maryland_voters_by_county %>% inner_join(maryland_counties_with_shapes, by=c('FIPS'='GEOID'))
```

Now we can do some calculations and visualize them on a map. Let's calculate the number of Unaffiliated (no party) voters per 10,000 people and take a look at just the numbers.

```{r}
md_una_per_10k <- maryland_voters_by_county_with_pop %>%
  mutate(una_per_10k = UNA/TOTAL_POP*10000) %>%
  arrange(desc(una_per_10k)) %>%
  select(County, DEM, REP, OTH, UNA, TOTAL, una_per_10k, geometry)

md_una_per_10k
```
Let's take a look at the result of this table. We might call this where the swing voters are, although political science tells us that most independents actually vote with a party most of the time. Frederick, Howard, Calvert, Anne Arundel and Carroll counties all have some competitive races at the local and state level, so that makes some sense. Montgomery, the state's largest jurisdiction, has more independents than Republicans.

Okay, now let's visualize. We're going to build a choropleth map, with the color of each county -- the fill -- set according to the number of unaffiliated voters per 10K on a color gradient.

```{r}
#| error: true

ggplot() +
  geom_sf(data=md_una_per_10k, aes(fill=una_per_10k)) +
  theme_minimal()
```
So this error message is pretty sneaky, because it's saying that it can't find a geometry column. But we *have* a geometry column - it's called geometry! What's happening here is that ggplot expects certain details in order to be able to locate the column with geometry in it, and sometimes when we build a new dataframe through joins those details get dropped. Luckily, we can explicitly tell ggplot where to find it:

```{r}
ggplot() +
  geom_sf(data=md_una_per_10k, aes(fill=una_per_10k, geometry=geometry)) +
  theme_minimal()
```
This map is okay, but the color scale makes it hard to draw fine-grained differences. Let's try applying the magma color scale we learned in the last chapter.

```{r}
ggplot() +
  geom_sf(data=md_una_per_10k, aes(fill=una_per_10k, geometry=geometry)) +
  theme_minimal() +
  scale_fill_viridis_b(option="magma")
```
Some interesting regional patterns finally emerge.

The highest number of unaffiliated voters per capita are clustered close to DC and Baltimore, with the notable exception of Prince George's County. The further west you go, the lower number of unaffiliated voters per capita there are (and that's somewhat true for the Eastern Shore, too). You could swap out UNA for Republicans or Democrats, or look at this another way, but what you're trying to see here are potential patterns for further exploration.
